// src/common.ts
import {
  createServer as createHttpServer
} from "http";
function createMiddleware(handler, options = {}) {
  const {
    origin = process.env.ORIGIN,
    trustProxy = process.env.TRUST_PROXY === "1"
  } = options;
  let { protocol, host } = origin ? new URL(origin) : {};
  if (protocol) {
    protocol = protocol.slice(0, -1);
  }
  return async (req, res, next) => {
    var _a, _b;
    function getForwardedHeader(name) {
      return (String(req.headers["x-forwarded-" + name]) || "").split(",", 1)[0].trim();
    }
    protocol = protocol || req.protocol || trustProxy && getForwardedHeader("proto") || ((_a = req.socket) == null ? void 0 : _a.encrypted) && "https" || "http";
    host = host || trustProxy && getForwardedHeader("host") || req.headers.host;
    if (!host) {
      console.warn(
        "Could not automatically determine the origin host, using 'localhost'. Use the 'origin' option or the 'ORIGIN' environment variable to set the origin explicitly."
      );
      host = "localhost";
    }
    const ip = req.ip || trustProxy && getForwardedHeader("for") || ((_b = req.socket) == null ? void 0 : _b.remoteAddress) || "";
    let headers = req.headers;
    if (headers[":method"]) {
      headers = Object.fromEntries(
        Object.entries(headers).filter(([key]) => !key.startsWith(":"))
      );
    }
    const request = new Request(protocol + "://" + host + req.url, {
      method: req.method,
      headers,
      body: req.method === "GET" || req.method === "HEAD" ? void 0 : req.socket ? req : (
        // Convert to a ReadableStream for Deno
        new ReadableStream({
          start(controller) {
            req.on("data", (chunk) => controller.enqueue(chunk));
            req.on("end", () => controller.close());
            req.on("error", (err) => controller.error(err));
          }
        })
      ),
      // @ts-expect-error: Node requires this for streams
      duplex: "half"
    });
    let passThroughCalled = false;
    const context = {
      request,
      ip,
      waitUntil(promise) {
      },
      passThrough() {
        passThroughCalled = true;
      },
      platform: {
        request: req,
        response: res
      }
    };
    const response = await handler(context);
    if (!next || !passThroughCalled) {
      res.statusCode = response.status;
      for (const [key, value] of response.headers) {
        if (key === "set-cookie") {
          const setCookie = response.headers.getSetCookie();
          res.setHeader("set-cookie", setCookie);
        } else {
          res.setHeader(key, value);
        }
      }
      const contentLengthSet = response.headers.get("content-length");
      if (response.body) {
        if (contentLengthSet) {
          for await (let chunk of response.body) {
            chunk = Buffer.from(chunk);
            res.write(chunk);
          }
        } else {
          const reader = response.body[Symbol.asyncIterator]();
          const first = await reader.next();
          if (first.done) {
            res.setHeader("content-length", "0");
          } else {
            const secondPromise = reader.next();
            let second = await Promise.race([
              secondPromise,
              Promise.resolve(null)
            ]);
            if (second && second.done) {
              res.setHeader("content-length", first.value.length);
              res.write(first.value);
            } else {
              res.write(first.value);
              second = await secondPromise;
              for (; !second.done; second = await reader.next()) {
                res.write(Buffer.from(second.value));
              }
            }
          }
        }
      } else if (!contentLengthSet) {
        res.setHeader("content-length", "0");
      }
      res.end();
    }
    next == null ? void 0 : next();
  };
}
function createServer(handler, adapterOptions, serverOptions) {
  const listener = createMiddleware(handler, adapterOptions);
  return serverOptions ? createHttpServer(serverOptions, listener) : createHttpServer(listener);
}

export {
  createMiddleware,
  createServer
};
